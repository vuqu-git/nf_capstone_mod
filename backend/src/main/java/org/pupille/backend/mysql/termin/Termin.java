package org.pupille.backend.mysql.termin;

import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import org.pupille.backend.mysql.reihe.Reihe;
import org.pupille.backend.mysql.terminverknuepfung.Terminverknuepfung;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Entity
@Table(name = "termin") // Explicitly map to the database table "film"
@Data // Lombok annotation to generate getters, setters, equals, hashCode, and toString
@NoArgsConstructor // Lombok annotation to generate a no-argument constructor
public class Termin {

    @Id
    //    @Column(name = "tnr", nullable = false) // Map to "tnr" column in the database
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Use auto-increment
    //    GenerationType.IDENTITY tells JPA to rely on the database's identity column (auto-increment) to generate primary key values.
    //    This is specific to databases like MySQL that support auto-increment.
    private Long tnr; // Primary key

    @Column(nullable = false, name = "termin")
    private LocalDateTime vorstellungsbeginn; // datetime

    // @NotBlank // Ensure non-null and non-empty
    private String titel;

    @Column(columnDefinition = "TEXT")
    private String text;

    @Column(columnDefinition = "TEXT")
    private String kurztext;

    @Column(columnDefinition = "TEXT")
    private String besonderheit;

    private String bild;

    @Column(name = "start_reservierung")
    private LocalDate startReservierung; // date

    private String linkReservierung;

    @Column(name = "sonderfarbe_titel")
    private Integer sonderfarbeTitel;

    private String sonderfarbe;

    private Short veroeffentlichen;

    private String patenschaft;

    // ############################################
    // relationships (extension of the entity model)

    @OneToMany(mappedBy = "termin", cascade = CascadeType.ALL)
    @JsonManagedReference("TV-Termin-Ref")
    // @EqualsAndHashCode.Exclude // maybe here as well like below for field reihen
    private List<Terminverknuepfung> filmConnections = new ArrayList<>();

    @ManyToMany(mappedBy = "termine") // Mapped by the "termine" field in Reihe
    // No @JsonManagedReference or @JsonBackReference here for Many-to-Many-relationships if you're using JsonIgnore on the other side => Simply allow it to be serialized normally as part of Termin.
    //      Why @JsonManagedReference/@JsonBackReference is tricky for direct M-M:
    //      => These annotations are primarily designed for one-to-many/many-to-one or one-to-one relationships where one side can logically point back to a single instance of the other side.
    //
    // Exclude from Lombok's equals/hashCode, to avoid ConcurrentModificationException: often arises when Hibernate is trying to load or merge a collection, and the equals/hashCode methods, generated by Lombok, are inadvertently causing the collection to be "modified" (or its internal state to be accessed in a way Hibernate isn't expecting during its loading process)
    // By default, @Data generates equals() and hashCode() that include all fields
    // => The Solution: Exclude Collection Fields from Lombok's equals()/hashCode()
    @EqualsAndHashCode.Exclude
    private Set<Reihe> reihen = new HashSet<>();
    // ############################################
}
